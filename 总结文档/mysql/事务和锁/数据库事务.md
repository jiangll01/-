####  数据库事务和锁

**事务经典场景**
​ 在很多介绍事务的博客都会代入这样一个场景，先简单说说：

 A给B转账100，A少100，B多100。如果A少100后系统崩溃怎么办？B的钱多不了，这样金钱总数凭空少了100。这里就需要用到事务了。

#####  1、事务的特点（ACID）

**事务**：事务是恢复和并发控制的基本单位，是数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；这些操作作为一个整体一 起向系统提交，要么都执行、要么都不执行；事务是一组不可再分割的操作集合（工作逻辑单元）；

**事务的简单操作**

显式启动事务语句，begin或者start transaction;

提交commit;

回滚rollback;

mysql默认是自动提交

SET AUTOCOMMIT=0 禁止自动提交

SET AUTOCOMMIT=1 开启自动提交

**事务的四大特性：**

**原子性（Atomicity）**：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。（**跟java的原子性很相像，不允许被打断**）

若开启事务，在上述场景就不会出现 A少100 成功，B多100 失败 这种情况。MySQL通过**Redo Log**重做日志实现了原子性，在将执行SQL语句时，会先写入redo log buffer，再执行SQL语句，若SQL语句执行出错就会根据redo log buffer中的记录来执行回滚操作，由此拥有原子性。

**一致性（Consistency）**：一致性是指事务从一种一致性状态转变成另一种一致性状态。在事务开始之前和事务结束之后，数据库的完整性约束没有破坏。即：A和B一共5000元，无论双方进行多少次转账，他们的总和都只能是5000元。或者说表中有一个字段为name，为唯一约束，即在表中姓名不能重复。如果一个事务对name字段进行了修改，但是事务提交或者事务操作发生回滚后，表中的姓名变得非唯一了，这就破坏了事务的一致性要求。因此，事务是一致性单元，如果事务中某个动作失败了，系统可以自动撤销事务，返回初始状态。

**隔离性（Ioslation）**：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。即该事务提交前对其他事务都不可见。**通过锁或者MVCC实现**，**MVCC（多版本并发控制）**类比java的锁机制，通过加锁来解决这个问题

------

**首先介绍如果没有隔离性会发生的4种情况**

**丢失更新**

 A事务撤销时，把已经提交的B事务的更新数据覆盖了。这种错误可能造成很严重的问题，通过下面的账户取款转账就可以看出来，MySQL通过**三级封锁协议**的第一级解决了丢失更新，事务 A要修改数据 时必须加 X 锁(写锁)，直到 T 结束才释放锁。

<img src="C:\Users\jiangll01\AppData\Roaming\Typora\typora-user-images\image-20200805175303805.png" alt="image-20200805175303805" style="zoom:67%;" />

##### 脏读

 脏读主要是读取到了其他事务的数据，而其他事务随后发生回滚。MySQL通过三级封锁协议的第二级解决了脏读，在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。

<img src="C:\Users\jiangll01\AppData\Roaming\Typora\typora-user-images\image-20200805175525660.png" alt="image-20200805175525660" style="zoom:67%;" />

##### 不可重复读

 不可重复读是读取到数据后，随后其他事务对数据发生了修改，无法再次读取。MySQL通过三级封锁协议的第三级解决了不可重复读。在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。

<img src="C:\Users\jiangll01\AppData\Roaming\Typora\typora-user-images\image-20200805175721677.png" alt="image-20200805175721677" style="zoom:67%;" />

**幻读**
​ 幻读是读取到数据后，随后其他事务对数据发生了新增，无法再次读取。在InnoDB引擎Repeatable Read的隔离级别下，MySQL通过Next-Key Lock以及MVCC解决了幻读，事务中分为当前读以及快照读。

1.快照读(snapshot read) ——通过MVCC来避免幻读

简单的select操作(不包括 select … lock in share mode, select … for update)

2.当前读(current read) ——通过Next-Key Lock 来避免幻读 Next-Key Lock即间隙锁（Gap Lock）+行锁 （Record Lock）

select … lock in share mode

select … for update

insert

update

delete

<img src="C:\Users\jiangll01\AppData\Roaming\Typora\typora-user-images\image-20200805175846021.png" alt="image-20200805175846021" style="zoom: 67%;" />



------

**持久性（Durability）**：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。具体实现原理就是在事务commit之前会将，redo log buffer中的数据持久化到硬盘中的redo log file，这样在commit的时候，硬盘中已经有了我们修改或新增的数据，由此做到持久化。

**在高并发环境下，事务类似于java中的代码块，通过操作事务来进行保证数据的安全性。**

------

**事务的隔离等级**

mysql默认的隔离等级是可重复读，如果想要在mysql启动时就修改mysql的隔离等级，需要修改配置文件，在[mysqld]中添加如下内容：

```mysql
[mysqld]
transaction-isolation = READ-COMMITTED
```

如果想要查看当前事务隔离级别，可以使用：

```mysql
mysql>select @@tx_isolation;
```

脏读：事务A读取了事务B更新、未提交的数据，然后B回滚操作，那么A读取到的数据是脏数据(没有用的数据)。

不可重复读：事务 B 在事务A多次读取的过程中，对数据作了更新操作并提交，导致事务A两次读取同一数据不一致。主要针对数据更新的。

幻读：同一事务中，两次按相同条件查询到的记录不一样。造成幻读的原因在于事务处理没有结束时，其他事务对同一数据集合增加或删除了记录。在mysql中MVCC在一定程度上解决了幻读，但并没有完全解决。如下：

事务在插入已经检查过不存在的记录时，插入失败，出现冲突显示这条数据已经存在了。比如：A查询id为2的数据不存在则插入一条id为2的数据，在事务A查询完毕后，事务B插入了一条id为2的数据，并提交了。此时事务A向表中插入id为2的数据插入失败。第二次的insert其实也属于隐式的读取，只不过是在mysql的机制中读取的，插入数据也是要先读取一下有没有主键冲突才能决定是否执行插入。

不可重复读和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。

**读未提交**

最低级别，任何情况都无法保证，可能造成脏读、幻读、不可重复读，效率最高，但最不安全。

**读提交**

可避免脏读的发生。

**可重复读**

可避免脏读、不可重复读的发生。（mysql默认的级别）

可重复读就是在一个事务内，对于同一个查询请求，多次执行，获取到的数据集是一样的。这一般是通过保存事务的快照实现的。**MVCC**会保存某个时间点上的快照，意味着事务可以看到一个一致性的状态。但是不同事务在同一个时间点上看到同一个表中的数据可能是不同的。

**串行化**

可避免脏读、不可重复读、幻读的发生。但是效率最低。事务的最高级别，在每个读的数据行上，加上锁，使之不可能相互冲突。如果有事务对该数据行操作，那么其他事务就要等他结束才能进行操作。

**MVCC**

可重复读使用的是一种叫**MVCC**的控制方式 ，即Mutil-Version Concurrency Control，**多版本并发控制**。InnoDB在每行记录后面保存两个隐藏的列来，**分别保存了这个行的创建时间和行的删除时间**。这里存储的并不是实际的时间值,而是**系统版本号**。每开启一个新事务，事务的版本号就会递增。所以增删改查中对版本号的作用如下：

**insert**：把当前系统（事务）版本号作为行记录的版本号。

- 创建一个事务，ID为1，插入两条数据。

  ```mysql
  begin;
  insert into user(name) values('xiaoqi');
  insert into user(name) values('dada');
  commit;
  ```

  |  id  |  name  | 创建时间(事务ID) | 删除时间(事务ID) |
  | :--: | :----: | :--------------: | :--------------: |
  |  1   | xiaoqi |        1         |    undefined     |
  |  2   |  dada  |        1         |    undefined     |

**select**：事务每次只能读到行记录的版本号小于等于此次系统版本号的记录，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。在事务自身执行过程中，不会读取到其他事务进行的操作。

行的删除版本要么未定义,要么大于当前事务版本号(这可以确保事务读取到的行，在事务开始之前未被删除)， 只有条件1、2同时满足的记录，才能返回作为查询结果。

**delete**：把当前系统版本号作为行记录的删除版本号。

- 创建第二个事务，ID为2，进行删除处理。

  ```mysql
  begin;
  select * from user;   # 执行事务2的第一步
  select * from user;   # 执行事务2的第二步
  commit;
  ```

假设1：在执行ID为2的事务第一步的时候，有另一个事务ID为3往这个表里插入了一条数据;

- 创建第三个事务，ID为3

  ```mysql
  begin;
  insert into user(name) values('jianren');
  commit;
  ```

  表数据如下：

  |  id  |  name   | 创建时间(事务ID) | 删除时间(事务ID) |
  | :--: | :-----: | :--------------: | :--------------: |
  |  1   | xiaoqi  |        1         |    undefined     |
  |  2   |  dada   |        1         |    undefined     |
  |  3   | jianren |        3         |    undefined     |

  然后，继续执行ID为2的事务的第二步，由于id=3的数据的创建时间(事务ID为3)，执行当前事务的ID为2，而InnoDB只会查找事务ID小于等于当前事务ID的数据行，所以id=3的数据行并不会在执行事务2中的第二步被检索出来，在事务2中的两条select 语句检索出来的数据均如下表：

  |  id  |  name  | 创建时间(事务ID) | 删除时间(事务ID) |
  | :--: | :----: | :--------------: | :--------------: |
  |  1   | xiaoqi |        1         |    undefined     |
  |  2   |  dada  |        1         |    undefined     |

假设2：在执行ID为2的事务第一步之后，假设执行完ID为3的事务后，接着又执行了ID为4的事务。

- 创建第四个事务，ID为4

  ```mysql
  begin; 
  delete from user where id=1; 
  commit;
  ```

  此时数据库中表如下：

  |  id  |  name   | 创建时间(事务ID) | 删除时间(事务ID) |
  | :--: | :-----: | :--------------: | :--------------: |
  |  1   | xiaoqi  |        1         |        4         |
  |  2   |  dada   |        1         |    undefined     |
  |  3   | jianren |        3         |    undefined     |

  然后执行ID为2的事务的第二步。根据SELECT 检索条件可以知道，它会检索创建时间(创建事务的ID)小于当前事务ID的行和删除时间(删除事务的ID)大于当前事务ID的行,而id=3的行上面已经说过，而id=1的行由于删除时间(删除事务的ID)大于当前事务的ID，所以事务2的第二步select * from user;也会把id=1的数据检索出来。最终，事务2中的两条select 语句检索出来的数据都如下：

  |  id  |  name  | 创建时间(事务ID) | 删除时间(事务ID) |
  | :--: | :----: | :--------------: | :--------------: |
  |  1   | xiaoqi |        1         |        4         |
  |  2   |  dada  |        1         |    undefined     |

**update**：插入一条新记录，并把当前事务版本号作为行记录的版本号，同时保存当前系统版本号到原有的行作为删除版本号。

假设3：假设在执行完事务2的第一步后，其它用户执行了事务3、4，这时，又有一个用户对这张表执行了UPDATE操作，创建了第五个事务，ID为5。

- 第五个事务，ID为5

  ```mysql
  begin; 
  update user set name='dazi' where id=2;
  commit;
  ```

  此时数据库中表如下：

  |  id  |  name   | 创建时间(事务ID) | 删除时间(事务ID) |
  | :--: | :-----: | :--------------: | :--------------: |
  |  1   | xiaoqi  |        1         |        4         |
  |  2   |  dada   |        1         |        5         |
  |  3   | jianren |        3         |    undefined     |
  |  2   |  dazi   |        5         |    undefined     |

  继续执行事务2的第二步，根据select 语句的检索条件，得到下表：

  |  id  |  name  | 创建时间(事务ID) | 删除时间(事务ID) |
  | :--: | :----: | :--------------: | :--------------: |
  |  1   | xiaoqi |        1         |        4         |
  |  2   |  dada  |        1         |        5         |

  还是和事务2中第一步select 得到相同的结果。

这就是mysql中事务的可重复读，即一个事务执行后，无论其他事务对其进行怎样的修改读到的数据都是一样的，也就是可以重复读多少次结果都一样。不过这就可能出现同一时刻两个用户读到的数据不同。

**快照读和当前读**

- 快照读：读取的是快照版本，也就是历史版本
- 当前读：读取的是最新版本
- 普通的select就是快照读，而update，delete，insert，select...LOCK In SHARE MODE（共享锁）,SELECT...for update（排他锁）就是当前读，其实执行update，delete，insert的时候也是先进行读取数据，然后进行操作。



