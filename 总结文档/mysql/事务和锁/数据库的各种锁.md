##### 数据库的各种锁

**mysql中锁的概念有很多，乐观锁、悲观锁、共享锁、排他锁、表锁、行锁等，他们之间有什么关系呢**

**乐观锁**

乐观锁大多是基于数据版本记录机制实现，一般是给数据库表增加一个"version"字段。读取数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。（CAS啊）

 1、如果有人在你之前更新了，你的更新应当是被拒绝的，可以让用户重新操作。

  2、实现：大多数基于数据版本（Version）记录机制实现

   具体可通过给表加一个版本号或时间戳字段实现，当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断当前版本信息与第一次取出来的版本值大小，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据，拒绝更新，让用户重新操作。

**悲观锁**

悲观锁依靠数据库提供的锁机制实现。MySQL中的共享锁和排它锁都是悲观锁。数据库的增删改操作默认都会加排他锁，而查询不会加任何锁。
  1、排它锁，当事务在操作数据时把这部分数据进行锁定，直到操作完毕后再解锁，其他事务操作才可操作该部分数据。这将防止其他进程读取或修改表中的数据。

  2、实现：大多数情况下依靠数据库的锁机制实现

   一般使用 select ...for update 对所选择的数据进行加锁处理，例如select * from account where name=”Max” for update， 这条sql 语句锁定了account 表中所有符合检索条件（name=”Max”）的记录。本次事务提交之前（事务提交时会释放事务过程中的锁），外界无法修改这些记录。

**共享锁（读锁）**

共享锁指的就是对于多个不同的事务，对于一个资源共享同一个锁。对某一资源加共享锁，自身可可读该资源，其他人也可以读该资源（也可以再加共享锁，即共享锁共享多个内存），但无法修改。要想修改就必须等所有共享锁都释放完之后。语法：`select * from table lock in share mode;`

共享锁数据行锁，允许不同事务共享加锁读取，但不允许其它事务修改或者加入排他锁。如果有修改必须等待一个事务提交完成，才可以执行，容易出现死锁

例如：事务1已经获得了行r的共享锁，那么另外的事务2可以立即获得行r的共享锁，因为读取并没有改变行r的数据，称这种情况为锁兼容。

```mysql
select * from user where id = 1 lock in share mode;  # 共享锁的写法
```

**排他锁（写锁）**

排他锁属于行锁，当一个事物加入排他锁后，不允许其他事务加共享锁或者排它锁读取，更加不允许其他事务修改加锁的数据行。

例如：事务1已经获得了行r的共享锁，若有事务3想获得行r的排他锁，则必须等事务1释放行r上的锁，这种情况称为锁不兼容。

```mysql
select * from user where id = 1 for update;  # 排他锁的写法
```

InnoDB存储引擎支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎还提供了一种额外的加锁方式，称为意向锁，意向排他锁是表级别的锁。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。

**行锁**

行锁就是给一行数据进行加锁，操作对象是数据表中的一行（共享锁和排他锁可能是行锁也可能是表锁，取决于对数据加锁的范围，是一行还是整个表）。是MVCC技术用的比较多的，但在MYISAM用不了，行级锁用mysql的储存引擎实现而不是mysql服务器。但行级锁对系统开销较大，处理高并发较好。

**表锁**

表锁就是对一张表进行加锁，操作对象是数据表。Mysql大多数锁策略都支持(常见mysql innodb)，是系统开销最低但并发性最低的一个锁策略。事务t对整个表加读锁，则其他事务可读不可写，若加写锁，则其他事务增删改都不行。

独占锁

临键锁

**PS**：

当前读、快照读，record lock(记录锁)、gap lock(间隙锁)、next-key lock

本来只有串读隔离级别才可以解决幻读问题，而实际上由于快照读的特性使可重复读也解决了幻读问题。

当前读是因为innodb默认为它加入了间隙锁，防止在事务期间对相关数据集插入记录，从而避免出现幻读。

在RR级别下，快照读是通过MVVC(多版本控制)和undo log来实现的，当前读是通过加record lock(记录锁)和gap lock(间隙锁)来实现的。如果需要实时显示数据，还是需要通过手动加锁来实现。这个时候会使用next-key技术来实现。

在mysql中，提供了两种事务隔离技术，第一个是mvcc，第二个是next-key技术。这个在使用不同的语句的时候可以动态选择。不加lock inshare mode之类的快照读就使用mvcc。否则 当前读使用next-key。mvcc的优势是不加锁，并发性高。缺点是不是实时数据。next-key的优势是获取实时数据，但是需要加锁。

Record lock
单条索引记录上加锁，record lock锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，那么锁住的就是这个隐藏的聚集主键索引。所以说当一条sql没有走任何索引时，那么将会在每一条聚集索引后面加X锁，这个类似于表锁，但原理上和表锁应该是完全不同的。

Gap Lock 

在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。gap lock的机制主要是解决可重复读模式下的幻读问题。

**行锁和间隙锁组合起来就叫Next-Key Lock。**

**间隙锁、**

间隙锁定是对索引记录之间的间隙的锁定，或者是对第一个或最后一个索引记录之前的间隙的锁定，锁定一个范围，但不包含记录本身。例如，`SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;`阻止其他事务将value `15`插入column中`t.c1`，无论该列 中是否已经存在该值，因为范围内所有现有值之间的间隙都被锁定。

间隙可能跨越单个索引值，多个索引值，甚至为空。

对于使用唯一索引来锁定唯一行来锁定行的语句，不需要间隙锁定。（这不包括搜索条件仅包含多列唯一索引的某些列的情况；在这种情况下，会发生间隙锁定。）例如，如果该`id`列具有唯一索引，则以下语句仅使用一个索引记录锁定`id`值为100 的行，其他会话是否在前面的间隙中插入行都没有关系：

```sql
SELECT * FROM child WHERE id = 100;
```

如果`id`未建立索引或索引不唯一，则该语句会锁定前面的间隙。

间隙锁可以共存。一个事务进行的间隙锁定不会阻止另一事务对相同的间隙进行间隙锁定。共享和专用间隙锁之间没有区别。它们彼此不冲突，并且执行相同的功能。

自增锁

**意向锁**

意向锁的作用：意图锁是表级锁，指示事务稍后需要对表中的行使用哪种类型的锁（共享或独占）。意向锁意味着事务希望在更细粒度上进行加锁。

**为什么没有意向锁，表锁和行锁不能共存？**

假设事务A写锁锁住了某一行，其他事务就不可能修改这一行。这与”事务B锁住整个表就能修改表中的任意一行“形成了冲突。所以，没有意向锁的时候，行锁与表锁共存就会存在问题！

有了意向锁之后，前面例子中的事务A在申请行锁（写锁）之前，数据库会自动先给事务A申请表的意向排他锁。当事务B去申请表的写锁时就会失败，因为表上有意向排他锁之后事务B申请表的写锁时会被阻塞。

![img](https://img2018.cnblogs.com/blog/1644414/201911/1644414-20191113113917652-1122986692.png)

若将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象进行上锁，那么首先需要对粗粒度的对象上锁。如上图，如果对页上的记录上排他锁，那么分别需要对数据库A、表、页上意向锁，最后对记录上排他锁。若其中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成。这其实也是为什么Myisam数据库引擎的查询速度更优于InnoDB数据库引擎的原因，锁加的多了自然就慢了。

InooDB存储引擎意向锁的设计目的主要在于为了在一个事务中解释下一行即将被请求的锁类型。其支持两种意向锁：

**意向共享锁（IS Lock）**：事务在获取表中某行上的共享锁之前，必须先获取表上的IS锁。

**意向排他锁（IX Lock）**：事务在获取表中某行的排他锁之前，必须先获取该表的IX锁。

**表级锁类型的兼容性汇总在下表**

|            | 意向共享锁 | 意向排他锁 | 共享表锁 | 排他表锁 |
| ---------- | ---------- | ---------- | -------- | -------- |
| 意向共享锁 | 兼容       | 兼容       | 兼容     | 不兼容   |
| 意向排他锁 | 兼容       | 兼容       | 不兼容   | 不兼容   |
| 共享表锁   | 兼容       | 不兼容     | 兼容     | 不兼容   |
| 排他表锁   | 不兼容     | 不兼容     | 不兼容   | 不兼容   |

**记录锁定**是对索引记录的锁定。例如， `SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;` 可以防止从插入，更新或删除行，其中的值的任何其它交易`t.c1`是 `10`

记录锁定始终锁定索引记录，即使没有定义索引的表也是如此。对于这种情况，请 `InnoDB`创建一个隐藏的聚集索引，并将该索引用于记录锁定。

**Next-Key Lock**

是Record Lock+Gap Lock的组合，锁定一个记录范围，并锁定记录本身。

例如一个索引有10，11，13和20这四个值，那么该索引可能被锁定的区间为：

```mysql
(-∞,10]
(10,11]
(11,13]
(13,20]
(20,+∞)
```

如果查询的索引是聚集索引时，InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身，而不是范围。

```mysql
create table t(a int primary key);
insert into t values(1);
insert into t values(2);
insert into t values(5);
```

接着执行sql

创建事务A

```mysql
begin;
select * from t where a=5 for update;
commit;
```

如果在事务A提交之前，创建事务B并插入一条数据，且提交。

```mysql
# 事务B
begin;
insert into t values(4);
commit;  # 成功不需要阻塞
```

表t中有1，2，5三个值，在事务A对a = 5进行排他锁锁定。而由于a是主键且唯一，因此锁定的仅是5这个值，而不是(2,5)这个范围，这样事务B插入值4时可以立即插入，不会阻塞。Next-Key Lock降级为Record Lock，从而提高并发性。

若是辅助索引，即则会阻塞等待上一事务提交后才能继续执行。比如：一个表a中有辅助索引四个值m为1、2、4、6，一个辅助索引使用Next-Key Lock锁定条件是4，代码如下，那么他锁定的范围是(2,4)，但特别注意的是，InnoDB存储引擎还会对辅助索引下一个键值加上gap lock，即还有一个辅助索引范围为(4,6)的锁。因此若执行插入m=5的sql语句会被阻塞。

```mysql
select * from a where m=4 for update;
```

通过Next-Key Lock可以避免幻读的出现。