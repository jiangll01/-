# MySQL索引

索引类似大学图书馆建书目索引，可以提高数据检索的效率，降低数据库的IO成本。MySQL在300万条记录左右性能开始逐渐下降，虽然官方文档说500~800w记录，所以大数据量建立索引是非常有必要的。MySQL提供了Explain，用于显示SQL执行的详细信息，可以进行索引的优化。

**什么是索引？**

MySQL官方对索引的定义为：索引(Index)是帮助MySQL高效获取数据的数据结构。我们可以简单理解为：快速查找排好序的一种数据结构。Mysql索引主要有两种结构：B+Tree索引和Hash索引。我们平常所说的索引，如果没有特别指明，一般都是指B树结构组织的索引(B+Tree索引)。索引如图所示：

![img](https://img.jbzj.com/file_images/article/201903/2019320105441607.png?2019220105459)

最外层浅蓝色磁盘块1里有数据17、35（深蓝色）和指针P1、P2、P3（黄色）。P1指针表示小于17的磁盘块，P2是在17-35之间，P3指向大于35的磁盘块。真实数据存在于子叶节点也就是最底下的一层3、5、9、10、13……非叶子节点不存储真实的数据，只存储指引搜索方向的数据项，如17、35。

查找过程：例如搜索28数据项，首先加载磁盘块1到内存中，发生一次I/O，用二分查找确定在P2指针。接着发现28在26和30之间，通过P2指针的地址加载磁盘块3到内存，发生第二次I/O。用同样的方式找到磁盘块8，发生第三次I/O。

真实的情况是，上面3层的B+Tree可以表示上百万的数据，上百万的数据只发生了三次I/O而不是上百万次I/O，时间提升是巨大的。

数据表索引可以提高数据的检索效率，也可以降低数据库的IO成本，并且索引还可以降低数据库的排序成本。排序分组操作主要消耗的就是CPU资源和内存，所以能够在排序分组操作中好好的利用索引将会极大地降低CPU资源的消耗。下面下面我们将简单的分析一下怎样正确创建MySQL数据索引。

**怎样判断是否需要创建索引？**

**1、某些字段需要频繁用作查询条件时需要为它建立索引**

这个应该都知道，什么样才是频繁呢？综合分析你执行的所有SQL语句。最好将他们一个个都列出来。然后分析，发现其中有些字段在大部分的SQL语句查询时候都会用到，那么就果断为他建立索引。

**2、唯一性太差的字段不适合建立索引**

什么是唯一性太差的字段？如状态字段、类型字段。那些只存储固定几个值的字段，例如用户登录状态、消息的status等。这个涉及到了索引扫描的特性。例如：通过索引查找键值为A和B的某些数据，通过A找到某条相符合的数据，这条数据在X页上面，然后继续扫描，又发现符合A的数据出现在了Y页上面，那么存储引擎就会丢弃X页面的数据，然后存储Y页面上的数据，一直到查找完所有对应A的数据，然后查找B字段，发现X页面上面又有对应B字段的数据，那么他就会再次扫描X页面，等于X页面就会被扫描2次甚至多次。以此类推，所以同一个数据页可能会被多次重复的读取，丢弃，在读取，这无疑给存储引擎极大地增加了IO的负担。

**3、更新太频繁地字段不适合创建索引**

当你为某个字段创建索引时候，如果再次更新这个字段数据时，数据库就会自动更新他的索引，所以当这个字段更新太频繁地时候那么就会不断的更新索引，性能的影响可想而知。大概被检索几十次才会更新一次的字段才比较符合建立索引的规范。而如果一个字段同一个时间段内被更新多次，那么果断不能为他建立索引。

**4、不会出现在where条件中的字段不该建立索引**

这个其实没什么好说的，不会用作查询条件的字段建立了索引也没用。

**索引创建过程**

**Innodb中存储空间管理的最小单位是页，页的默认空间是16KB，每个页中存放了数据。页与页之间是通过双向链表来连接的。索引页中的数据都会按照主键的值从小到大排列并用单向链表连接起来。**

**我们先说说在没有索引的情况下是怎么查找一条记录的。 因为每个页中数据都是没有规律的，所以我们不得不遍历所有的页来得到这条数据。这样查询的效率就会很低。所以需要为记录生成一个目录页来记录这些数据。**

**在建立目录的过程中规定了下一个数据页的主键值必须大于上一个数据页的主键值。当一个页中的数据超出了范围了就产生一个新的页存放，这个过程会产生页分裂，数据的移动，比如主键值小的会跑去上一个页，主键值大的往后一个页移动。**

**正确创建索引**

> 尽量使用自增长主键

使用自增长主键的原因笔者认为有两个。首先能有效减少页分裂，MySQL中数据是以页为单位存储的且每个页的大小是固定的（默认16kb），如果一个数据页的数据满了，则需要分成两个页来存储，这个过程就叫做页分裂。

如果使用了自增主键的话，新插入的数据都会尽量的往一个数据页中写，写满了之后再申请一个新的数据页写即可（大多数情况下不需要分裂，除非父节点的容量也满了）。

自增主键

![img](http://file.mycookies.cn/201805191537_258.gif?imageView1/JannLee/md/01)

非自增主键

![img](http://file.mycookies.cn/201805191538_202.gif?imageView1/JannLee/md/01)

其次，对于缓存友好。系统分配给MySQL的内存有限，对于数据量比较多的数据库来说，通常只有一小部分数据在内存中，而大多数数据都在磁盘中。如果使用无序的主键，则会造成随机的磁盘IO，影响系统性能

#####  索引创建与删除

聚集索引，聚集索引一般是主键列

辅助索引，辅助索引辅助聚集索引

**聚集索引生成过程**

MySQL会自动选择主键作为聚集索引列，没有主键列会选择唯一键，如果都没有会生成隐藏的主键列

MySQL进行存储时，会按照聚集索引列值的顺序，有序存储数据行

聚集索引直接将原表**数据页**，作为叶子结点，然后提取聚集索引列向上生成枝和根

**辅助索引生成过程**

管理员选择一个列创建辅助索引

MySQL会自动将此列的值取出来

将此列的值自动排序

将排好序的数据，均匀的存储到索引的叶子节点

生成枝节点和根节点

**辅助索引的使用过程**

先遍历辅助索引，找到对应的索引键值所对应的id值或者是主键值，进而使用主键值回到聚集索引，再进行遍历查询找到指行数据

**聚集索引和辅助索引的区别**

表中的任何一个列都可以创建辅助索引，在你有需要的时候，只要名字不同即可在一张表中，聚集索引只能有一个，一般是主键辅助索引，叶子结点只存储索引列的有序值聚集索引，叶子结点存储的是有序的整行数据MySQL的表数据存储是聚集索引组织表

**字段长度**

业务允许，尽量选择长度短的列作为索引列

业务不允许，选择前缀索引

**数据类型**

对于变长长度的列来讲，使用varchar类型比char类型要有优势。对于大表而言，使用char数据类型的每个索引长度都是固定值，空格也算在索引的长度里面，而varchar不是。所以叶子结点的消耗较大，因而要选择varchar数据类型

#####   MySQL索引底层实现原理

**Innodb中存储空间管理的最小单位是页，页的默认空间是16KB，每个页中存放了数据。页与页之间是通过双向链表来连接的。索引页中的数据都会按照主键的值从小到大排列并用单向链表连接起来。**

**我们先说说在没有索引的情况下是怎么查找一条记录的。 因为每个页中数据都是没有规律的，所以我们不得不遍历所有的页来得到这条数据。这样查询的效率就会很低。所以需要为记录生成一个目录页来记录这些数据。**

**在建立目录的过程中规定了下一个数据页的主键值必须大于上一个数据页的主键值。当一个页中的数据超出了范围了就产生一个新的页存放，这个过程会产生页分裂，数据的移动，比如主键值小的会跑去上一个页，主键值大的往后一个页移动。**

**2，0，3这些是页的头信息，2表示的是最小记录，0表示普通记录，3表示的是最大记录，还有就是如果是1的话表示的是目录项记录**![img](https://img2018.cnblogs.com/blog/1721996/201906/1721996-20190621134842844-1911441852.png)

 

 

 **但是问题来了，页与页之间可能并不是相邻的，也就是说可能上一个页的页号是10，下一个页的页号是20，但是这些页之间是通过双向链表来进行连接的。那么怎么去快速访问到特定的页号呢，答案就是再为每个目录页再建立一个目录项：**

![img](https://img2018.cnblogs.com/blog/1721996/201906/1721996-20190621134915175-38448190.png)

 

**每一个目录项中包含了两个内容，一个是目录页中的最小主键值，另一个是页目录号就是页号。这样就可以快速的根据主键值定位到一条记录。这种目录项就叫做索引**