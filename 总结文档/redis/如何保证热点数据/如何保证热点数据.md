1.限定 Redis 占用的内存，Redis 会根据自身数据淘汰策略，加载热数据到内存。
所以，计算一下 20W 数据大约占用的内存，然后设置一下 Redis 内存限制即可。

 

2.问题是什么数据？

比如用户数据。数据库有2000w条。
活跃用户：
redis sortSet里 放两天内(为方便取一天内活跃用户)登录过的用户，登录一次ZADD一次，如set已存在则覆盖其分数（登录时间）。键：login:users，值：分数 时间戳、value userid。设置一个周期任务，比如每天03:00:00点删除sort set中前一天3点前的数据（保证set不无序增长、留近一天内活跃用户）。

取时，拿到当前时间戳（int 10位），再减1天就可按分数范围取过去24h活跃用户。

 

3.看你的提问,应该只是把Redis当缓存来用.
提供一种简单实现缓存失效的思路: LRU(最近少用的淘汰)
即redis的缓存每命中一次,就给命中的缓存增加一定ttl(过期时间)(根据具体情况来设定, 比如10分钟).
一段时间后, 热数据的ttl都会较大, 不会自动失效, 而冷数据基本上过了设定的ttl就马上失效了.

 

4.

redis 内存数据集大小上升到一定大小的时候，会施行数据淘汰策略。

redis 提供 6种数据淘汰策略：

redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。redis 提供 6种数据淘汰策略：
volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
no-enviction（驱逐）：禁止驱逐数据