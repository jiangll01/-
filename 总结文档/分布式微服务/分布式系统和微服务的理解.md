#####  分布式系统和微服务的理解

------

微服务设计思想和分布式的部署方式

![img](https://pic1.zhimg.com/80/v2-e628e972ac34b597ba2c1f7f0d326705_1440w.jpg)

**单机结构**

我想大家最最最熟悉的就是单机结构，一个系统业务量很小的时候所有的代码都放在一个项目中就好了，然后这个项目部署在一台服务器上就好了。整个项目所有的服务都由这台服务器提供。这就是单机结构。

那么，单机结构有啥缺点呢？我想缺点是显而易见的，单机的处理能力毕竟是有限的，当你的业务增长到一定程度的时候，单机的硬件资源将无法满足你的业务需求。此时便出现了集群模式，往下接着看。

**集群结构**

集群模式在程序猿界有各种装逼解释，有的让你根本无法理解，其实就是一个很简单的玩意儿，且听我一一道来。

单机处理到达瓶颈的时候，你就把单机复制几份，这样就构成了一个“集群”。集群中每台服务器就叫做这个集群的一个“节点”，所有节点构成了一个集群。每个节点都提供相同的服务，那么这样系统的处理能力就相当于提升了好几倍（有几个节点就相当于提升了这么多倍）。

但问题是用户的请求究竟由哪个节点来处理呢？最好能够让此时此刻负载较小的节点来处理，这样使得每个节点的压力都比较平均。要实现这个功能，就需要在所有节点之前增加一个“调度者”的角色，用户的所有请求都先交给它，然后它根据当前所有节点的负载情况，决定将这个请求交给哪个节点处理。这个“调度者”有个牛逼了名字——负载均衡服务器。

集群结构的好处就是系统扩展非常容易。如果随着你们系统业务的发展，当前的系统又支撑不住了，那么给这个集群再增加节点就行了。但是，当你的业务发展到一定程度的时候，你会发现一个问题——无论怎么增加节点，貌似整个集群性能的提升效果并不明显了。这时候，你就需要使用微服务结构了。

**分布式结构**

先来对前面的知识点做个总结。

从单机结构到集群结构，你的代码基本无需要作任何修改，你要做的仅仅是多部署几台服务器，每台服务器上运行相同的代码就行了。但是，当你要从集群结构演进到微服务结构的时候，之前的那套代码就需要发生较大的改动了。所以对于新系统我们建议，系统设计之初就采用微服务架构，这样后期运维的成本更低。但如果一套老系统需要升级成微服务结构的话，那就得对代码大动干戈了。所以，对于老系统而言，究竟是继续保持集群模式，还是升级成微服务架构，这需要你们的架构师深思熟虑、权衡投入产出比。

OK，下面开始介绍所谓的分布式结构。

分布式结构就是将一个完整的系统，按照业务功能，拆分成一个个独立的子系统，在分布式结构中，每个子系统就被称为“服务”。这些子系统能够独立运行在web容器中，它们之间通过**RPC方式通信**。

举个例子，假设需要开发一个在线商城。按照微服务的思想，我们需要按照功能模块拆分成多个独立的服务，如：用户服务、产品服务、订单服务、后台管理服务、数据分析服务等等。这一个个服务都是一个个独立的项目，可以独立运行。如果服务之间有依赖关系，那么通过RPC方式调用。

这样的好处有很多：

1. 系统之间的耦合度大大降低，可以独立开发、独立部署、独立测试，系统与系统之间的边界非常明确，排错也变得相当容易，开发效率大大提升。
2. 系统之间的耦合度降低，从而系统更易于扩展。我们可以针对性地扩展某些服务。假设这个商城要搞一次大促，下单量可能会大大提升，因此我们可以针对性地提升订单系统、产品系统的节点数量，而对于后台管理系统、数据分析系统而言，节点数量维持原有水平即可。
3. 服务的复用性更高。比如，当我们将用户系统作为单独的服务后，该公司所有的产品都可以使用该系统作为用户系统，无需重复开发。

#####  一、**事务**

**分布式事务**、**事务隔离级别**、**ACID**我相信大家这些东西都耳熟能详了，那什么是事务呢？

概念：

**一般是指要做的或所做的事情。**

在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。

事务通常由高级数据库操纵语言或编程语言（如SQL，C++或Java）书写的用户程序用户程序的执行所引起，并用形如**begin transaction**和**end transaction**语句（或函数调用）来界定。

事务由事务开始(**begin transaction**)和事务结束(**end transaction**)之间执行的全体操作组成。

**事务是为解决数据安全操作提出的，事务控制实际上就是控制数据的安全访问。**

用一个简单例子说明：银行转帐业务，账户A要将自己账户上的1000元转到B账户下面，A账户余额首先要减去1000元，然后B账户要增加1000元。假如在中间网络出现了问题，A账户减去1000元已经结束，B因为网络中断而操作失败，那么整个业务失败，必须做出控制，要求A账户转帐业务撤销。这才能保证业务的正确性，完成这个操走就需要事务，**将A账户资金减少和B账户资金增加放到同一个事务里**，要么全部执行成功，要么全部撤销，这样就保证了数据的安全性。


特性：

事务是恢复和并发控制的基本单位。

事务应该具有4个属性：**原子性、一致性、隔离性、持久性**。这四个属性通常称为**ACID特性**。

**原子性（atomicity）**：一个事务是一个不可分割的工作单位，事务中包括的操作要么都做，要么都不做。

**一致性（consistency）**：事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。

**隔离性（isolation）**：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。

**持久性（durability）**：**持久性也称永久性（permanence）**，指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。

那有同学还是不理解，总结了一下就是：**事务就是一系列操作，要么同时成功，要么同时失败。**然后会从事务的 **ACID** 特性**（原子性、一致性、隔离性、持久性）展开叙述**。

#####  二、分布式事务的了解

这里举个简单的例子：大家可以想一下，你下单流程可能涉及到10多个环节，你下单付钱都成功了，但是你优惠券扣减失败了，积分新增失败了，前者公司会被薅羊毛，后者用户会不开心。	

但是这些都在不同的服务怎么保证大家都成功呢？ 分布式事务。

**分布式事务是指会涉及到操作多个数据库的事务。其实就是将对同一库事务的概念扩大到了对多个库的事务**。目的是为了保证分布式系统中的数据一致性。分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务的决定必须产生统一的结果（全部提交或全部回滚）

------

分布式系统有一个著名的CAP理论，即一个分布式系统要同时满足一致性（Consistency）、可用性（Availablility）和分区容错（Partition Tolerance）三个特性是一件不可能的事情。

一致性（Consistency）：一致性指的是数据的强一致性。每次的读操作都是读取的最新数据。即如果写入某个数据成功的话，之后的读取都应该读的是新写入的数据；如果写入失败的话，之后读取的都不应该是写入失败的数据。

可用性（Availability）：可用性指的是服务的可用性。即每个请求都能在合理的时间内获得符合预期的响应结果。

分区容错性（Partition Tolerance）：分区容错性指的是当节点之间的网络出现问题之后，系统仍然能够正常提供服务。

在分布式的系统中，P是基本要求，而单体应用则是CA系统。微服务系统通常是一个AP系统，即同时满足可用性和分区容错性。这样就有了一个在分布式系统中保证数据强一致性的难题，这个难题的一个解决方案就是分布式事务。

------

**分布式事务的解决方案**

在微服务系统中，每个服务都是独立的进程单元，每个服务都有自己的数据库。在通常情况下，只有关系型数据库在特定的数据引擎下才会支持事务（本地事务），而大多数非关系型数据库是不支持事务的，比如MongDB完全不支持事务，而Redis是支持事务的，虽然支持得不完整。

两阶段提交

网上购物在日常生活中是一个非常普通的场景，假设静静在某宝上购买了一个玩具，需要从静静的账户中扣除200块钱，同时玩具的库存数量需要减1，卖家的账户中增加200块钱。

如果这是一个单体应用，并且使用支持事务的数据库（比如InnoDB数据库引擎的MySQL、Oracle和SQL Server等），我们可能是这样写代码的：

```
@Transactional
public void update() throws RuntimeException{
    updateAccountTable(); // 更新账户表
    updateGoodsTable(); // 更新商品表
}
```

如果是微服务架构的话，账户是一个服务，商品是一个服务，两个独立的服务就不能使用数据库自带的事务了，因为这两个数据表可能并不在一个数据库中，这就需要用到两阶段提交的解决方案。

![img](https://img2018.cnblogs.com/blog/842514/201907/842514-20190726220243803-2023463088.png)

**第一阶段**，service-account发起一个分布式事务，交给事务式事务TC处理，事务协调器TC向所有参与事务的节点发送处理事务操作的准备操作。所有参与节点执行准备操作，将Undo和Redo信息写入日志中，并向事务管理器返回准备操作是否成功的消息。

**第二阶段**，事务管理器收集所有节点的准备操作是否都成功，如果都成功的话则通知所有的节点执行提交操作，如果有一个失败则执行回滚操作。

两阶段提交将事务分成了两个部分，大大提高了分布式事务的成功概率。然而，如果在第一阶段都成功了，而执行第二阶段的某一个节点失败，仍然会导致数据不准确。这种情况下一般需要人工去处理，这也是为什么要在第一步记录日志的原因。

另外，如果分布式事务涉及的节点很多，一旦某一个节点的网络出现异常，就会导致整个事务处于阻塞状态，大大降低数据库的性能。因此如果不是必要的话，建议是尽量少用分布式事务，有些时候过度设计反而会造成相反的效果。

三阶段提交

三阶段提交在两阶段提交的步骤中间加了一层预提交事务阶段。

**1.CanCommit阶段。**这个阶段和上面说的两阶段提交的准备阶段类似，不同的地方就是并没有进行诸如将Undo和Redo的信息写入事务日志的其他操作。

**2.PreCommit阶段。**这个阶段是一个缓冲，目的是推迟Commit的决定，只有保证所有参与者都知道了Commit的决定之后，才会真正发出Commit的决定。所有的参与者都会在这个阶段记录Undo和Redo的信息，并且当协调者发生故障之后，所有的参与者还能互相通信来确定事务是提交还是终止。

**3.DoCommit阶段。**这个阶段就是事务的真正提交，如果所有的参与者都向协调者发送了ACK响应，那么协调者就会完成事务，否则中断事务。

![img](https://img2018.cnblogs.com/blog/842514/201907/842514-20190726223210103-757796445.png)

三阶段提交的方案引入了对参与者的超时机制，相比于两阶段提交只有协调者拥有超时的机制，三阶段提交解决了协调者突然挂掉引起的参与者一直阻塞的问题。

本质上来说，三阶段提交避免了状态停滞的问题。在两阶段提交的过程中有可能会因为各种原因产生状态停滞的问题，最明显的就是协调者突然宕机的情况。但是三阶段提交即使是协调者宕机也会让状态继续下去，参与者们也会互相通信确定事务是提交还是终止，从而使状态继续下去，哪怕状态是错的。

------

**Tip**：真实的应用场景可能比我介绍的场景复杂数倍，我只是为了举例方便一下大家理解所以用了很简单的例子。

我接触和了解到的分布式事务大概分为：

- 2pc（两段式提交）
- 3pc（三段式提交）
- TCC（Try、Confirm、Cancel）
- 最大努力通知
- XA
- 本地消息表（ebay研发出的）
- 半消息/最终一致性（RocketMQ）

这里我就介绍下最简单的**2pc（两段式）**，以及大家以后可能比较常用的**半消息事务**也就是**最终一致性**，目的是让大家理解下分布式事务里面**消息中间件的作用**，别的事务都大同小异，都有很多优点。

当然也都有**种种弊端**：

例如**长时间锁定数据库资源**，导致系统的**响应不快**，**并发上不去**。

网络抖动出现**脑裂**情况，导致事物参与者，不能很好地执行协调者的指令，导致**数据不一致**。

**单点故障**：例如事物协调者，在某一时刻宕机，虽然可以通过选举机制产生新的Leader，但是这过程中，必然出现问题，而TCC，只有强悍的技术团队，才能支持开发，**成本太高**。

不多BB了，我们开始介绍这个两个事物吧。

------

**2pc（两段式提交）** 

![img](https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1FpzjaiaLbo3bKFDic8zvesZQQYzeRTVOMHUU1zjE9ObAdR8nmaL9RGpVM6KarWONOKQsQ7bLOibKcY1icg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**2pc（两段式提交）**可以说是分布式事务的最开始的样子了，像极了**媒婆**，就是通过消息中间件协调多个系统，在两个系统操作事务的时候都锁定资源但是不提交事务，等两者都准备好了，告诉消息中间件，然后再分别提交事务。

**但是我不知道大家看到问题所在没有？**

是的你可能已经发现了，如果A系统事务提交成功了，但是B系统在提交的时候网络波动或者各种原因提交失败了，其实还是会失败的。

**最终一致性**：

![img](https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1FpzjaiaLbo3bKFDic8zvesZQQYGzqjLEEExfaHBB0EkbQvEvIIaiaaAdMtdr12KgEfc0ktpqHMQibnau4g/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

整个流程中，我们能保证是：

- 业务主动方本地事务提交失败，业务被动方不会收到消息的投递。
- 只要业务主动方本地事务执行成功，那么消息服务一定会投递消息给下游的业务被动方，并最终保证业务被动方一定能成功消费该消息（消费成功或失败，即最终一定会有一个最终态）。

不过呢技术就是这样，**各种极端的情况我们都需要考虑**，也很难有完美的方案，所以才会有这么多的方案**三段式**、**TCC**、**最大努力通知**等等分布式事务方案，大家只需要知道为啥要做，做了有啥好处，有啥坏处，在实际开发的时候都注意下就好好了，**系统都是根据业务场景设计出来的，离开业务的技术没有意义，离开技术的业务没有底气**。

还是那句话：**没有最完美的系统，只有最适合的系统。**

------

